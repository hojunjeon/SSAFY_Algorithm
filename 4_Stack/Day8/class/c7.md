미리보기 모드: 전자우편 알림이 설정되지 않았습니다.
×


검색



Status is "Online".
4

채널 탐색

채널

개인 메시지

2

4. 온/오프라인코칭

At 오후 3:08 2월 11일 수요일, 금기륜 강사[서울_6반] wrote, - DFS 코드 ```python import sys sys.stdin = open("input.txt", "r") # 시작점: 1번 node # 종료지점: 갈 수 있는 모든 노드를 방문했을 때 def dfs(node): print(node, end=' ') # 현재 방문한 노드를 출력 # 현재 node 로 부터 갈 수 있는 노드들을 방문 # 전체 노드를 확인 for next_node in range(1, N + 1): # 갈 수 없는 노드는 pass if graph[node][next_node] == 0: continue # 이미 방문한 노드라면 pass if visited[next_node]: continue visited[next_node] = 1 # 방문 처리 dfs(next_node) # 다음 노드로 이동 # 정점 수, 간선 수 N, M = map(int, input().split()) # 인접 행렬 # - 0번은 버린다고 가정하고, 7*7로 생성 graph = [[0] * (N + 1) for _ in range(N + 1)] # 방문여부를 기록 visited = [0] * (N + 1) # 그래프 연결 for _ in range(M): start, end = map(int, input().split()) graph[start][end] = 1 graph[end][start] = 1 # 양방향 그래프 visited[1] = 1 dfs(1) ```
최근 메시지로 이동6 new messages 오늘
2월 03일

금기륜 강사[서울_6반]
오후 3:50
내장 함수 sort 활용법 익히기
그리디 문제에서 정렬이 자주 나옵니다.
오름차순, 내림차순, 정렬기준 수정해보기 등을 모두 잘 활용해야 합니다!
sort 문제
arr = [5, 1, 4, 2, 3]

# [문제 1]
# 정수 리스트를 오름차순으로 정렬하세요.
# - list.sort() 를 사용할 것
# - 원본 리스트가 변경되는지 확인하세요
# - 반환값이 있는지 확인하세요
# Todo: 이곳에 정렬 코드를 작성하세요

print("기본 리스트:", arr)


words = ["apple", "banana", "kiwi"]

# [문제 2]
# 문자열 리스트를 "문자열 길이" 기준으로 오름차순 정렬하세요.
# - key 옵션을 반드시 사용하세요
# - lambda 식을 사용하세요
# - 각 원소의 길이를 어떻게 꺼낼지 고민해보세요
# Todo: 이곳에 정렬 코드를 작성하세요

print("문자열 리스트:", words)


data = [(1, 90), (3, 80), (2, 90)]

# [문제 3-1]
# 튜플 리스트를 기본 정렬 기준으로 정렬하세요.
# - key 옵션 없이 정렬했을 때 어떤 값이 기준이 되는지 확인하세요
# Todo: 이곳에 정렬 코드를 작성하세요

# [문제 3-2]
# 튜플의 두 번째 값(점수)을 기준으로 오름차순 정렬하세요.
# - lambda 를 사용하세요
# - x[1] 이 의미하는 바를 생각해보세요
# Todo: 이곳에 정렬 코드를 작성하세요

# [문제 3-3]
# 점수 오름차순, 점수가 같으면 첫 번째 값 오름차순으로 정렬하세요.
# - key 에서 튜플을 반환하도록 작성하세요
# Todo: 이곳에 정렬 코드를 작성하세요

# [문제 3-4]
# 점수는 내림차순, 첫 번째 값은 오름차순으로 정렬하세요.
# - 숫자 내림차순을 어떻게 표현하는지 고민해보세요
# Todo: 이곳에 정렬 코드를 작성하세요

print("튜플 리스트:", data)


scores = {
    "kim": 90,
    "lee": 85,
    "park": 90
}

# [문제 4-1]
# 딕셔너리를 key 기준으로 정렬하세요.
# - dict 자체는 정렬되지 않음을 기억하세요
# - items() 를 사용해야 하는 이유를 생각해보세요
# Todo: 이곳에 정렬 코드를 작성하세요

# [문제 4-2]
# 딕셔너리를 value 기준으로 오름차순 정렬하세요.
# - lambda 에서 x[0], x[1] 이 각각 무엇인지 확인하세요
# Todo: 이곳에 정렬 코드를 작성하세요

# [문제 4-3]
# value 기준 내림차순으로 정렬하세요.
# - reverse 옵션을 사용할지, key 에서 처리할지 고민해보세요
# Todo: 이곳에 정렬 코드를 작성하세요

print("딕셔너리:", scores)


class Student:
    def __init__(self, name, score):
        self.name = name
        self.score = score

    def __repr__(self):
        return f"{self.name}:{self.score}"


students = [
    Student("kim", 90),
    Student("lee", 85),
    Student("park", 90)
]

# [문제 5-1]
# Student 객체 리스트를 점수 기준 오름차순으로 정렬하세요.
# - 객체 자체는 비교가 불가능함을 떠올리세요
# - key 에서 어떤 값을 반환해야 할지 생각해보세요
# Todo: 이곳에 정렬 코드를 작성하세요

# [문제 5-2]
# 점수는 내림차순, 이름은 오름차순으로 정렬하세요.
# - 다중 기준 정렬입니다
# - 튜플을 반환하는 key 를 작성하세요
# Todo: 이곳에 정렬 코드를 작성하세요

print("학생 객체 리스트:", students)
더보기

금기륜 강사[서울_6반]
오후 4:15
sort 문제 정답
arr = [5, 1, 4, 2, 3]

# [문제 1]
# 정수 리스트를 오름차순으로 정렬하세요.
# - list.sort() 를 사용할 것
# - 원본 리스트가 변경되는지 확인하세요
# - 반환값이 있는지 확인하세요
arr.sort()  # 원본 리스트 자체가 변경됨, 반환값은 None

print("기본 리스트:", arr)


words = ["apple", "banana", "kiwi"]

# [문제 2]
# 문자열 리스트를 "문자열 길이" 기준으로 오름차순 정렬하세요.
# - key 옵션을 반드시 사용하세요
# - lambda 식을 사용하세요
# - 각 원소의 길이를 어떻게 꺼낼지 고민해보세요
words.sort(key=lambda x: len(x))

print("문자열 리스트:", words)


data = [(1, 90), (3, 80), (2, 90)]

# [문제 3-1]
# 튜플 리스트를 기본 정렬 기준으로 정렬하세요.
# - key 옵션 없이 정렬했을 때 어떤 값이 기준이 되는지 확인하세요
data.sort()

# [문제 3-2]
# 튜플의 두 번째 값(점수)을 기준으로 오름차순 정렬하세요.
# - lambda 를 사용하세요
# - x[1] 이 의미하는 바를 생각해보세요
data.sort(key=lambda x: x[1])

# [문제 3-3]
# 점수 오름차순, 점수가 같으면 첫 번째 값 오름차순으로 정렬하세요.
# - key 에서 튜플을 반환하도록 작성하세요
data.sort(key=lambda x: (x[1], x[0]))

# [문제 3-4]
# 점수는 내림차순, 첫 번째 값은 오름차순으로 정렬하세요.
# - 숫자 내림차순을 어떻게 표현하는지 고민해보세요
data.sort(key=lambda x: (-x[1], x[0]))

print("튜플 리스트:", data)


scores = {
    "kim": 90,
    "lee": 85,
    "park": 90
}

# [문제 4-1]
# 딕셔너리를 key 기준으로 정렬하세요.
# - dict 자체는 정렬되지 않음을 기억하세요
# - items() 를 사용해야 하는 이유를 생각해보세요
sorted_by_key = sorted(scores.items())

# [문제 4-2]
# 딕셔너리를 value 기준으로 오름차순 정렬하세요.
# - lambda 에서 x[0], x[1] 이 각각 무엇인지 확인하세요
sorted_by_value = sorted(scores.items(), key=lambda x: x[1])

# [문제 4-3]
# value 기준 내림차순으로 정렬하세요.
# - reverse 옵션을 사용할지, key 에서 처리할지 고민해보세요
sorted_by_value_desc = sorted(scores.items(), key=lambda x: x[1], reverse=True)

print("딕셔너리 key 기준 정렬:", sorted_by_key)
print("딕셔너리 value 기준 정렬:", sorted_by_value)
print("딕셔너리 value 내림차순 정렬:", sorted_by_value_desc)
print("딕셔너리:", scores)


class Student:
    def __init__(self, name, score):
        self.name = name
        self.score = score

    def __repr__(self):
        return f"{self.name}:{self.score}"


students = [
    Student("kim", 90),
    Student("lee", 85),
    Student("park", 90)
]

# [문제 5-1]
# Student 객체 리스트를 점수 기준 오름차순으로 정렬하세요.
# - 객체 자체는 비교가 불가능함을 떠올리세요
# - key 에서 어떤 값을 반환해야 할지 생각해보세요
students.sort(key=lambda s: s.score)

# [문제 5-2]
# 점수는 내림차순, 이름은 오름차순으로 정렬하세요.
# - 다중 기준 정렬입니다
# - 튜플을 반환하는 key 를 작성하세요
students.sort(key=lambda s: (-s.score, s.name))

print("학생 객체 리스트:", students)
더보기

금기륜 강사[서울_6반]
오후 4:29
[참고] sort 에서 lambda 를 꼭 안써도 괜찮습니다.
아래도 가능한 코드입니다.
def func(x):
    return (-x[1], x[0])

words = ["apple", "banana", "kiwi"]
words.sort(key=func)
print(words)
2월 04일

금기륜 강사[서울_6반]
오전 11:30
2026-02-04(수) 수업 내용 요약
1. 이차원 리스트 다뤄보기

2. 델타 ?

3. 델타 실습
  - 24771. 청구서 재계산
  - 좌표 상하좌우 탐색

4. 부분집합 & 비트 연산 (10분 정도만)
  - 나중에 응용 파트 때 자세히
실습 input
5
45 15 10 56 23
96 98 99 40 69
96 84 49 46 34
16 64 81 4 11
10 66 85 55 14

금기륜 강사[서울_6반]
오후 12:17
1. 이차원 리스트 다뤄보기

import sys
sys.stdin = open("input.txt", "r")

# 1. 입력
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]

# 2. 가로부터 접근
for y in range(5):
    for x in range(5):
        # print(y, x)  # 좌표값 출력
        print(arr[y][x], end=' ')

    print()

print('---------------------------------')

# 3. 세로부터 접근
# for x in range(5):
#     for y in range(5):
#         print(arr[y][x], end=' ')
#
#     print()

# 반복문은 고정하고, 내부 위치만 바꿔도 된다.
for i in range(5):
    for j in range(5):
        print(arr[j][i], end=' ')
    print()

print('---------------------------------')

# 4. 대각선 접근
# 4.1 우하단 대각선 (\)
for i in range(5):
    print(arr[i][i])

print('---------------------------------')

# 4.2 좌하단 대각선 (/)
for i in range(5):
    # print(i, 4-i)
    print(arr[i][4-i])

print('---------------------------------')

# 5. 범위 접근
# - 3*3 사각형 범위값들을 한 번에 접근
# - 예시) 합이 가장 큰 3*3 범위 값을 구하여라


# 출발지를 전달받아서, 3*3 영역의 합을 계산하는 함수
def cal_total(sy, sx):
    total = 0
    for y in range(sy, sy + 3):  # 출발지 ~ 출발지 + 3
        for x in range(sx, sx + 3):
            # 범위 밖 계산 체크를 항상 합시다!
            # 1. [권장] 범위 밖은 계산하지 마라
            if y > 4 or y < 0 or x > 4 or x < 0:
                continue

            total += arr[y][x]

            # 2. 범위 안에 들어왔을 때만 계산해라
            #   - 추후 조건이 많아지면 가독성이 떨어진다.
            # if 0 <= y <= 4 and 0 <= x <= 4:
            #     total += arr[y][x]

    return total


max_total = 0
max_y, max_x = 0, 0

# 계산하고자 하는 출발지를 반복
for sy in range(5):
    for sx in range(5):
        total = cal_total(sy, sx)
        # max_total = max(max_total, total)  # 값만 필요하다면
        # 좌표값까지 같이 저장
        if total > max_total:
            max_total = total
            max_y = sy
            max_x = sx

print(max_y, max_x, max_total)
더보기

금기륜 강사[서울_6반]
오후 2:22
24771 .청구서 재계산 문제
델타란 ?
- delta란 무엇인가 ?
  - 변화량
  - 코딩에서의 delta 리스트
    - 변화량을 저장해놓은 리스트

- 구현 순서
  - 1. delta list 구현
  - 2. delta 값을 누적해나가면서 계산
순서대로 델타 리스트 구현해보기
- 두 번째 예시 delta 리스트
6
0 0 0 0 0 0
2
0 2 3
1 4 -1

delta : 3 -1 0 -3 0 1

- 세 번째 예시 delta 리스트와 계산 방법
4
10 20 30 40
2
0 3 5
1 3 -10

delta : 5 -10 0 0
now_delta : -5

15 15 25 35

금기륜 강사[서울_6반]
오후 2:58
청구서 재계산 정답 코드
delta list 의 계산 핵심: 값을 앞에서부터 누적해나가면서 계산
import sys
sys.stdin = open("input.txt", "r")

T = int(input())

for tc in range(1, T + 1):
    N = int(input())
    arr = list(map(int, input().split()))

    delta = [0] * (N + 1)  # 마지막 인덱스는 버린다

    P = int(input())
    for _ in range(P):
        start, end, cost = map(int, input().split())
        delta[start] += cost
        delta[end + 1] -= cost

    current_delta = 0  # 현재 시점의 변화량
    for i in range(N):
        current_delta += delta[i]  # 누적
        arr[i] += current_delta

    print(f'#{tc}', *arr)
    # [참고] f-string 안에 넣고싶다면 아래와 같이 join 활용
    # print(f'#{tc} {" ".join(map(str, arr))}')

금기륜 강사[서울_6반]
오후 3:22
방향 배열 활용하기

import sys
sys.stdin = open("input.txt", "r")

# 상하좌우 순서의 델타 리스트
dy = [-1, 1, 0, 0]
dx = [0, 0, -1, 1]

y, x = 3, 1

# 상하좌우 4방향
for i in range(4):
    now_y = y + dy[i]
    now_x = x + dx[i]
    print(now_y, now_x)

print()
# ------------------------------

dy = [-1, -1, 0, 1, 1, 1, 0, -1]
dx = [0, 1, 1, 1, 0, -1, -1, -1]

y, x = 3, 1

# 대각선 포함 8방향 확인
for i in range(8):
    now_y = y + dy[i]
    now_x = x + dx[i]
    print(now_y, now_x)

금기륜 강사[서울_6반]
오후 4:26
24781. 경건한 파리채 정답 코드
델타 배열의 원리를 반드시 이해하고 활용해야 합니다
import sys
sys.stdin = open("input.txt", "r")

# 상하좌우 델타
dy = [-1, 1, 0, 0]
dx = [0, 0, -1, 1]

T = int(input())

for tc in range(1, T + 1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]

    max_y, max_x, max_total = 0, 0, 0

    # sy, sx : 파리채를 치는 지점
    for sy in range(N):
        for sx in range(N):
            # (sy, sx) + 상하좌우 값 -> 더한다.
            total = arr[sy][sx]

            for i in range(4):
                new_y = sy + dy[i]
                new_x = sx + dx[i]

                # 해당 방향의 좌표가 범위를 벗어나면 continue
                if new_y < 0 or new_y >= N or new_x < 0 or new_x >= N:
                    continue

                total += arr[new_y][new_x]

            # 최대값 갱신
            if total > max_total:
                max_y = sy
                max_x = sx
                max_total = total

    print(f"#{tc} {max_total} {max_y} {max_x}")
더보기

금기륜 강사[서울_6반]
오후 4:53
[참고] 비트 연산 가볍게 살펴보기
나중에 응용 파트 때 다시 한 번 다룹니다
저런 게 있구나! 정도만 이해해주세요
# 비트 연산
# - bit : 0 or 1 을 나타내는 값
# - bit 의 개념을 활용하는 연산

print(1)
print(1 << 1)  # 0010(2) = 2
print(1 << 2)  # 0100(2) = 4

# -------------------

# 전체 부분집합 구하는 과정

arr = [1, 2, 3]
n = len(arr)

subsets = []

# 1 << n : 전체 부분집합의 수
for mask in range(1 << n):        # 0 ~ 2^n - 1
    subset = []
    # i : 각 자리수
    for i in range(n):
        # if mask & (1 << i) : 해당 자리 수의 숫자가 현재 부분집합에 포함 되어 있는 지?
        if mask & (1 << i):       # i번째 비트가 1인지 확인
            subset.append(arr[i])
    subsets.append(subset)

print(subsets)

# ---------------------------

# =========================
# 상태 비트 정의
# =========================
ATTACK = 1 << 0   # 0001
JUMP   = 1 << 1   # 0010
MOVE   = 1 << 2   # 0100
DEFEND = 1 << 3   # 1000


def print_status(status):
    states = []
    if status & ATTACK: states.append("ATTACK")
    if status & JUMP:   states.append("JUMP")
    if status & MOVE:   states.append("MOVE")
    if status & DEFEND: states.append("DEFEND")

    if not states:
        print("대기 상태")
    else:
        print(" + ".join(states))


# =========================
# 예제 1 : 대기 상태
# =========================
STATUS = 0
print("예제 1")
print_status(STATUS)
print()


# =========================
# 예제 2 : 공격 중
# =========================
STATUS = ATTACK
print("예제 2")
print_status(STATUS)
print()


# =========================
# 예제 3 : 이동하면서 공격
# =========================
STATUS = MOVE | ATTACK
print("예제 3")
print_status(STATUS)
print()


# =========================
# 예제 4 : 점프 공격
# =========================
STATUS = JUMP | ATTACK
print("예제 4")
print_status(STATUS)
print()


# =========================
# 예제 5 : 방어하면서 이동
# =========================
STATUS = DEFEND | MOVE
print("예제 5")
print_status(STATUS)
print()
더보기
목요일

금기륜 강사[서울_6반]
오후 2:15
2026-02-05(목) 실습 문제
달팽이 숫자 정답 코드
import sys
sys.stdin = open("input.txt", "r")


# 1. 현재 숫자(current) 가 1부터 N^2 까지 반복
# 2. 방향배열 : 우하좌상 순서
# 3. 바라보고 있는 방향 -> 계속 전진
#   - 방향 회전
#     - 벽을 만나거나
#     - 이미 숫자가 있는 곳을 만나면

# 방향배열 (우하좌상)
dy = [0, 1, 0, -1]
dx = [1, 0, -1, 0]

T = int(input())

for tc in range(1, T + 1):
    N = int(input())
    arr = [[0] * N for _ in range(N)]

    y, x = 0, 0
    current = 1
    direction = 0  # 현재 바라보고 있는 방향

    while current <= N * N:
        arr[y][x] = current  # 현재 자리에 숫자 저장

        # 다음 좌표를 갈 수 있는 곳인지 체크하는 코드 ------
        ny = y + dy[direction]
        nx = x + dx[direction]

        # if 다음좌표가 범위 밖 or 이미 데이터가 있다면:
        #     방향전환
        if ny < 0 or ny >= N or nx < 0 or nx >= N or arr[ny][nx]:
            # 0 1 2 3 0 1 2 3 을 반복해야함
            direction = (direction + 1) % 4

        # --------------------------------------

        current += 1  # 다음 숫자
        # 방향이 바뀌지 않았다면, 해당 방향으로 전진
        # 방향이 바뀌었다면, 바뀐 방향으로 전진
        y = y + dy[direction]  # 다음 좌표로 이동
        x = x + dx[direction]  # 다음 좌표로 이동

    print(f'#{tc}')
    for i in range(N):
        print(*arr[i])
더보기

금기륜 강사[서울_6반]
오후 2:39
슬라이딩 윈도우 기본 코드
# 슬라이딩 윈도우
# - 창(범위)이 미끄러지면서 범위에 대한 계산을 하는 문제들에서 활용
# - 해당 범위값을 반복문이 아니라
#   - 제외되는 부분을 없애주고
#   - 추가되는 부분만 계산해주는 방식

# 연속된 K개 숫자의 합 중 가장 큰 합을 구하여라
arr = [20, 32, 16, 25, 36, 23, 42, 53, 63, 46]

K = 5
window = sum(arr[:K])
max_sum = window   # 첫 윈도우 값으로 초기화

for i in range(len(arr) - K):
    window = window - arr[i] + arr[i + K]
    print(f'{i}위치 합 : {window}')
    if window > max_sum:
        max_sum = window

print("최대 합:", max_sum)

금기륜 강사[서울_6반]
오후 3:10
21921. 블로그 문제 정답 코드
import sys
sys.stdin = open("input.txt", "r")


N, X = map(int, input().split())
arr = list(map(int, input().split()))

window = sum(arr[:X])
max_window = window
max_day = 1

for i in range(N - X):
    window = window - arr[i] + arr[i + X]

    # 1. 최대 window 갱신
    if window > max_window:
        max_window = window
        max_day = 1
    # 2. 최대값이 동일하면, max_day += 1
    elif window == max_window:
        max_day += 1

# 최대 방문자 수가 0이면 SAD
if max_window == 0:
    print("SAD")
else:
    print(max_window)
    print(max_day)
금요일

금기륜 강사[서울_6반]
오후 5:38
주말동안 연습하면 좋은 문제들
시간을 1시간 30분정도 재면서 문제 풀어보기!
IM 대비문제
21889. 진우의 폭탄테러
21852. 새로운 Captcha Code
21704. 바이러스 죽이기
월요일

금기륜 강사[서울_6반]
오전 11:57
2026-02-09(월) - 스택과 큐

큐 (Queue)
- 먼저 온 데이터가 먼저 나가는 경우
- 일상생활 예시
  - 놀이공원 줄
  - 프린터기

스택 (Stack)
- 나중에 온 데이터가 먼저 나간다
- 일상생활 예시
  - ctrl + z
  - 브라우저 뒤로가기
  - 접시
금주 수업 내용 요약
스택
- 스택 자료구조 (최대한 마스터)
- 재귀호출 (최대한 마스터)
- 그래프 기초 - dfs (응용 파트 때 마스터)

큐
- 큐 자료구조 (최대한 마스터)
- 그래프 기초 - bfs (응용 파트 때 마스터)

금기륜 강사[서울_6반]
오후 12:13
재귀호출 기본 코드
반드시 그림을 그려보시기 바랍니다!!
# 재귀함수 구현
# - 시작지점
# - 종료지점
# - 누적된값

arr = [5, 2, 3, 4, 1]


# 1. 5 2 3 4 1 순서대로 출력하는 재귀함수를 구현하시오
# - 시작지점: 인덱스 0
# - 종료지점: 인덱스 4
# - 누적된값: 인덱스
def recur(idx):
    if idx == 4:
        print(arr[idx], end=' ')
        return

    print(arr[idx], end=' ')
    recur(idx + 1)  # 다음 인덱스를 전달하면서 다음 재귀호출

recur(0)
print()


# 2. 5 2 3 4 1 4 3 2 5 순서대로 출력하는 재귀함수를 구현하시오
# - 시작지점: 인덱스 0
# - 종료지점: 인덱스 4
# - 누적된값: 인덱스
def recur2(idx):
    if idx == 4:
        print(arr[idx], end=' ')
        return

    print(arr[idx], end=' ')  # 재귀 호출 전
    recur2(idx + 1)           # 다음 재귀 호출
    print(arr[idx], end=' ')  # 되돌아오면서 할 작업


recur2(0)
더보기

금기륜 강사[서울_6반]
오후 4:50
[S/W 문제해결 기본] 10일차 - 비밀번호 문제 정답
import sys
sys.stdin = open("input.txt", "r")

for tc in range(1, 11):
    arr = input().split()
    stack = []
    
    # 숫자를 보고
    # - 저장되어 있는 곳(==stack)의 마지막 숫자와 현재 숫자 비교

    for num in arr[1]:
        # 1. stack 이 비어있으면, 그냥 숫자를 stack 에 넣는다
        if len(stack) == 0:
            stack.append(num)
        # 2. stack 의 마지막 데이터와 현재 숫자를 비교한다.
        #   - 같다면, stack 의 마지막 숫자를 제거
        #   - 다르다면, stack 에 숫자를 추가
        else:
            if num == stack[-1]:
                stack.pop()
            else:
                stack.append(num)

    print(f'#{tc} {"".join(stack)}')

금기륜 강사[서울_6반]
오후 5:29
콜라츠 추측 정답 코드
import sys
sys.stdin = open("input.txt", "r")


# 재귀호출 구조
# - 시작: N
# - 끝: 1
# - 누적값(파라미터): 계산된 값
def recur(num):
    global cnt

    # num 이 1 이면 끝
    if num == 1:
        return

    cnt += 1

    # num 가 짝수면
    if num % 2 == 0:
        recur(num // 2)
    # num 가 홀수면
    else:
        recur(num * 3 + 1)


T = int(input())

for tc in range(1, T + 1):
    N = int(input())
    cnt = 0
    recur(N)
    print(f'#{tc} {cnt}')
더보기
어제

금기륜 강사[서울_6반]
오전 11:36
2026-02-10(화) 재귀호출 연습
피보나치 수 5
기본 재귀호출 활용
# fibo(10) = fibo(9) + fibo(8)
def fibo(num):
    if num <= 1:
        return num

    return fibo(num - 1) + fibo(num - 2)

N = int(input())
result = fibo(N)
print(result)

금기륜 강사[서울_6반]
오전 11:51
피보나치 수 2
재계산 하지말자! (메모이제이션 활용)
# fibo(10) = fibo(9) + fibo(8)
def fibo(num):
    if num <= 1:
        return num

    if memo.get(num):       # 계산한 적이 있다면
        return memo[num]    # 기존 기록된 값을 return

    # 한 번이라도 연산했다면, 딕셔너리에 기록
    memo[num] = fibo(num - 1) + fibo(num - 2)
    return memo[num]

N = int(input())
memo = {}
result = fibo(N)
print(result)

금기륜 강사[서울_6반]
오후 12:05
피보나치 수 7
DP 활용 문제
N = int(input())
mod = 1000000007
fibo = [0] * 1000001
fibo[0] = 0  # 초기값
fibo[1] = 1  # 초기값

# 세 번째 수부터는 이전의 값들을 활용할 수 있다
for i in range(2, 1000001):
    fibo[i] = (fibo[i-1] + fibo[i-2]) % mod

print(fibo[N])

금기륜 강사[서울_6반]
오후 2:16
팩토리얼
# 시작점: N
# 끝점: 1
# 누적값: n -> 1 내려가는 숫자
def factorial(num):
    if num <= 1:
        return 1

    return num * factorial(num - 1)



N = int(input())
result = factorial(N)
print(result)

금기륜 강사[서울_6반]
오후 2:42
이진수 변환
# 시작점: N
# 끝점: 0
# 누적값(전달되는값): N//2
def recur(num):
    if num == 0:
        return

    recur(num // 2)  # 2로 나눈 몫을 전달
    print(num % 2, end='')


N = int(input())
recur(N)
# return 으로 활용하기

# 시작점: N
# 끝점: 0
# 누적값(전달되는값): N//2
def recur(num):
    if num == 0:
        return ""

    return recur(num // 2) + str(num % 2)


N = int(input())
print(recur(N))

금기륜 강사[서울_6반]
오후 3:35
약수들의 합
import sys
sys.setrecursionlimit(10**6)


# 시작값: 1
# 끝점 : N // 2
# num: 1씩 증가하는 숫자, acc_list : 약수 리스트
def recur(num, acc_list):
    if num > N // 2:
        return acc_list
    
    # 약수 체크
    if N % num == 0:
        acc_list.append(num)
    
    return recur(num + 1, acc_list)


while True:
    N = int(input())

    if N == -1:
        break

    divisors = recur(1, [])

    if sum(divisors) == N:
        print(f'{N} = {" + ".join(map(str, divisors))}')
    else:
        print(f'{N} is NOT perfect.')
감추기
오늘

금기륜 강사[서울_6반]
오전 11:56
2026-02-11(수)
계산기1
연산자가 + 하나 일 때
def infix_to_postfix(tokens):
    result = []
    oper_stack = []

    # 1. 숫자면 그대로 result 에 쌓는다
    # 2. 연산자라면
    #   - oper_stack 이 비어있을 때: oper_stack 에 추가
    #   - 아닐 때
    #     - 나보다 우선순위가 크거나 같은 연산자들을 result 로 이동 후 추가

    for token in tokens:
        if token.isdigit():
            result.append(token)
        else:
            if oper_stack:
                result.append(oper_stack.pop())

            oper_stack.append(token)

    result.append(oper_stack.pop())  # 남은 연산자 하나

    return result


def get_result(tokens):
    stack = []
    # 숫자라면 그냥 stack 에 넣기
    # 연산자라면, stack 에서 숫자 2개 꺼내서 계산 후 다시 넣기
    for token in tokens:
        if token.isdigit():
            # 계산하기 위해서 int 로 변환하여 넣자
            stack.append(int(token))
        else:
            num1 = stack.pop()
            num2 = stack.pop()

            stack.append(num1 + num2)

    return stack[0]


for tc in range(1, 11):
    N = int(input())
    row = input()
    postfix = infix_to_postfix(row)  # 후위 표기법 으로 변환
    result = get_result(postfix)     # 계산
    print(f'#{tc} {result}')
감추기

금기륜 강사[서울_6반]
오후 12:17
계산기2
연산자가 *, + 두 가지 일 때
우선순위를 딕셔너리에 두고 비교한다
# 차이점1. 우선순위 존재
priority = {'+': 1, '*': 2}

def infix_to_postfix(tokens):
    result = []
    oper_stack = []

    # 1. 숫자면 그대로 result 에 쌓는다
    # 2. 연산자라면
    #   - oper_stack 이 비어있을 때: oper_stack 에 추가
    #   - 아닐 때
    #     - 나보다 우선순위가 크거나 같은 연산자들을 result 로 이동 후 추가

    for token in tokens:
        if token.isdigit():
            result.append(token)
        else:
            # 우선순위가 크거나 같은 연산자들을 차례로 이동
            # [주의사항] pop 이나 -1 등 조회할때는 항상 비어있는 지 먼저 체크!!
            while oper_stack and priority[oper_stack[-1]] >= priority[token]:
                result.append(oper_stack.pop())

            oper_stack.append(token)

    # 남은 연산자들을 모두 result 로 이동
    while oper_stack:
        result.append(oper_stack.pop())

    return result


def get_result(tokens):
    stack = []
    # 숫자라면 그냥 stack 에 넣기
    # 연산자라면, stack 에서 숫자 2개 꺼내서 계산 후 다시 넣기
    for token in tokens:
        if token.isdigit():
            # 계산하기 위해서 int 로 변환하여 넣자
            stack.append(int(token))
        else:
            num1 = stack.pop()
            num2 = stack.pop()

            if token == '+':
                stack.append(num1 + num2)
            elif token == '*':
                stack.append(num1 * num2)

    return stack[0]


for tc in range(1, 11):
    N = int(input())
    row = input()
    postfix = infix_to_postfix(row)  # 후위 표기법 으로 변환
    result = get_result(postfix)     # 계산
    print(f'#{tc} {result}')
더보기

금기륜 강사[서울_6반]
오후 12:23
계산기3 힌트
1. 여는 괄호는 oper_stack 에 그냥 넣자
2. 닫는 괄호라면
  - 여는 괄호를 만날 때 까지, 연산자를 하나 씩 꺼내서 result 로 이동
새로운 메시지

금기륜 강사[서울_6반]
오후 1:45
그래프 기초
만들려는 그래프


금기륜 강사[서울_6반]
오후 2:23
graph_basic.md
MD3KB
인접 행렬

인접 리스트


금기륜 강사[서울_6반]
오후 2:35
그래프 입력
6 7
1 2
1 3
1 4
2 4
2 5
4 5
4 6

금기륜 강사[서울_6반]
오후 3:08
DFS 코드
import sys
sys.stdin = open("input.txt", "r")


# 시작점: 1번 node
# 종료지점: 갈 수 있는 모든 노드를 방문했을 때
def dfs(node):
    print(node, end=' ')  # 현재 방문한 노드를 출력

    # 현재 node 로 부터 갈 수 있는 노드들을 방문
    # 전체 노드를 확인
    for next_node in range(1, N + 1):
        # 갈 수 없는 노드는 pass
        if graph[node][next_node] == 0:
            continue

        # 이미 방문한 노드라면 pass
        if visited[next_node]:
            continue

        visited[next_node] = 1  # 방문 처리
        dfs(next_node)  # 다음 노드로 이동

# 정점 수, 간선 수
N, M = map(int, input().split())

# 인접 행렬
# - 0번은 버린다고 가정하고, 7*7로 생성
graph = [[0] * (N + 1) for _ in range(N + 1)]
# 방문여부를 기록
visited = [0] * (N + 1)

# 그래프 연결
for _ in range(M):
    start, end = map(int, input().split())
    graph[start][end] = 1
    graph[end][start] = 1  # 양방향 그래프

visited[1] = 1
dfs(1)
더보기
4. 온/오프라인코칭에 글쓰기











예약


선택된 파일 없음


Message Sent &nbsp;
focalboard
playbooks
com.github.manland.mattermost-plugin-gitlab
graph_basic.md
금기륜 강사[서울_6반]Shared in ~4. 온/오프라인코칭

graph_basic.md - Markdown
# 그래프

## 그래프(Graph) 란?
- 자료구조 중 하나. 데이터 사이의 관계를 표현하기 위해 사용함
- 관계(Relation)
  - 데이터끼리 연결되어 있다.
  - ex) 경로가 있다, 비례한다 등등
- 현실에서 연결되어 있는 데이터들을 표현하기 위해 사용하는 자료구조
  - ex) 주식(시간-가격), 지하철(역1-역2), SNS(사용자1-사용자2) 등등
    
## 용어
- 정점(Vertex), 노드(Node)
  - 데이터(객체)를 나타내는 요소
- 간선(Edge)
  - 두 정점 사이의 연결(관계)을 나타내는 요소
  - 방향이 있는 간선과 방향이 없는(양방향) 간선이 존재함
    - 방향이 있는 간선 -> 방향 그래프
    - 양방향 간선 -> 무방향 그래프
    
## 그래프 종류
- 무방향 그래프
  - 간선에 방향이 없는 그래프
  - ex) 친구 관계, 인터넷 등
- 방향 그래프
  - 간선에 방향이 있는 그래프
  - ex) 팔로우/팔로워, 웹 페이지 링크 등
- 가중치 그래프
  - 간선 사이에 가중치(거리, 시간 등)가 존재하는 그래프
  - ex) 네비게이션 등
  - 문제) 최소 가중치, 최소 비용 문제 등등
- 연결 그래프
  - 모든 정점이 서로 연결되어 있는 그래프

## 이걸 어떻게 코드로 표현할까 ??
- 데이터와 연결여부를 코드로 표현해야 한다.
- 크게 두 가지 방법이 있다.

1. 인접 행렬
  - (V * V) 이차원 리스트로 표현
  - 간선 존재 여부를 모두 2차원 리스트에 저장
    - `graph[i][j] == 0` 이라면 i, j 사이에 간선이 존재하지 않음
    - `graph[i][j] == 1` 이라면 i, j 사이에 간선이 존재함

```python
# 그래프 예시
graph = [
    [0, 1, 1, 1, 0, 0],  # 1번의 연결 정보
    [1, 0, 0, 1, 1, 0],  # 2번의 연결 정보
    [1, 0, 0, 0, 0, 0],  # 3번의 연결 정보
    [1, 1, 0, 0, 1, 1],  # 4번의 연결 정보
    [0, 1, 0, 1, 0, 0],  # 5번의 연결 정보
    [0, 0, 0, 1, 0, 0],  # 6번의 연결 정보
]
```

- 장점: 구현이 쉽다. 특정 간선 존재 여부를 한 번에 알 수 있다.
- 단점: 메모리를 너무 많이 차지한다.

2. 인접 리스트
  - 연결 되어있는 정점에 대한 정보만 저장
  - `graph[i]`: i 정점에서 갈 수 있는 정점들에 대한 정보

```python
# index 기준으로 번호 작성
graph = [
    [], # 0번의 연결 정보 (0번은 생갹)
    [2, 3, 4],    # 1번의 연결 정보
    [1, 4, 5],    # 2번의 연결 정보
    [1],          # 3번의 연결 정보
    [1, 2, 5, 6],  # 4번의 연결 정보
    [2, 4],       # 5번의 연결 정보
    [4],          # 6번의 연결 정보
]
```

- 장점: 메모리가 효율적으로 관리된다.
- 단점: 특정 간선 존재 여부 확인이 느리다.